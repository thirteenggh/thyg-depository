<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="${namespace}">

  <insert id="createSchema">
    --
    -- each format has a browse node table
    --
    CREATE TABLE IF NOT EXISTS ${format}_browse_node (
      node_id       INT GENERATED BY DEFAULT AS IDENTITY,
      repository_id INT NOT NULL,
      parent_id     INT NOT NULL,
      display_name  VARCHAR NOT NULL,
      request_path  VARCHAR NOT NULL,
      component_id  INT,
      asset_id      INT,
      package_url   VARCHAR,

      CONSTRAINT pk_${format}_browse_node_id PRIMARY KEY (node_id),
      CONSTRAINT uk_${format}_browse_node_repository_path UNIQUE (repository_id, request_path),
      CONSTRAINT uk_${format}_browse_node_component UNIQUE (component_id),
      CONSTRAINT uk_${format}_browse_node_asset UNIQUE (asset_id),

      CONSTRAINT fk_${format}_browse_node_repository_id FOREIGN KEY (repository_id)
         REFERENCES ${format}_content_repository (repository_id) ON DELETE CASCADE,
      CONSTRAINT fk_${format}_browse_node_component FOREIGN KEY (component_id)
         REFERENCES ${format}_component (component_id) ON DELETE SET NULL,
      CONSTRAINT fk_${format}_browse_node_asset FOREIGN KEY (asset_id)
         REFERENCES ${format}_asset (asset_id) ON DELETE SET NULL

      -- skip FK for parent_id; doesn't work well when batch deleting from the root
    );

    CREATE INDEX IF NOT EXISTS idx_${format}_browse_node_tree
        ON ${format}_browse_node (repository_id, parent_id, display_name);
    --
  </insert>

  <resultMap id="browseNodeResult" type="BrowseNodeData">
    <!-- non-standard field mappings -->
    <result property="dbComponentId" column="component_id"/>
    <result property="dbAssetId" column="asset_id"/>
  </resultMap>

  <sql id="hasChild">
    SELECT 1 FROM ${format}_browse_node C WHERE C.repository_id = #{repositoryId} AND C.parent_id = B.node_id LIMIT 1
  </sql>

  <select id="hasComponentNode" resultType="boolean">
    SELECT EXISTS(SELECT 1 FROM ${format}_browse_node WHERE component_id = #{componentId});
  </select>

  <select id="hasAssetNode" resultType="boolean">
    SELECT EXISTS(SELECT 1 FROM ${format}_browse_node WHERE asset_id = #{assetId});
  </select>

  <select id="getByDisplayPath" resultMap="browseNodeResult">
    SELECT B.*, NOT EXISTS (<include refid="hasChild"/>) as leaf FROM
        <foreach collection="displayPath" index="i">
        ${format}_browse_node B${i},
        </foreach>
        ${format}_browse_node B
    WHERE 0 = <foreach collection="displayPath" index="i" item="name">
              B${i}.parent_id AND B${i}.repository_id = #{repositoryId} AND B${i}.display_name = #{name} AND B${i}.node_id =
              </foreach>
              B.parent_id AND B.repository_id = #{repositoryId}
        <if test="filter != null"> AND ${filter}</if>
        <if test="limit gt 0"> LIMIT #{limit}</if>;
  </select>

  <insert id="mergeBrowseNode" useGeneratedKeys="true" keyProperty="nodeId" parameterType="BrowseNodeData">
    MERGE INTO ${format}_browse_node (repository_id, request_path, display_name, parent_id, package_url
        <if test="dbComponentId != null">, component_id</if>
        <if test="dbAssetId != null">, asset_id</if>
    )
    KEY (repository_id, request_path) VALUES (#{repositoryId}, #{requestPath}, #{displayName}, #{parentId}, #{packageUrl}
        <if test="dbComponentId != null">, #{dbComponentId}</if>
        <if test="dbAssetId != null">, #{dbAssetId}</if>
    );
  </insert>

  <insert id="mergeBrowseNode" useGeneratedKeys="true" keyProperty="nodeId" parameterType="BrowseNodeData" databaseId="PostgreSQL">
    INSERT INTO ${format}_browse_node (repository_id, request_path, display_name, parent_id, package_url
        <if test="dbComponentId != null">, component_id</if>
        <if test="dbAssetId != null">, asset_id</if>
    )
    VALUES (#{repositoryId}, #{requestPath}, #{displayName}, #{parentId}, #{packageUrl}
        <if test="dbComponentId != null">, #{dbComponentId}</if>
        <if test="dbAssetId != null">, #{dbAssetId}</if>
    )
    ON CONFLICT (repository_id, request_path) DO UPDATE SET
        display_name = #{displayName}, parent_id = #{parentId}, package_url = #{packageUrl}
        <if test="dbComponentId != null">, component_id = #{dbComponentId}</if>
        <if test="dbAssetId != null">, asset_id = #{dbAssetId}</if>
    ;
  </insert>

  <delete id="trimBrowseNodes">
    DELETE FROM ${format}_browse_node B WHERE
        B.repository_id = #{repositoryId} AND B.component_id IS NULL AND B.asset_id IS NULL AND
        NOT EXISTS (SELECT 1 FROM ${format}_browse_node C WHERE
            C.repository_id = #{repositoryId} AND C.parent_id = B.node_id LIMIT 1);
  </delete>

  <delete id="deleteBrowseNodes">
    DELETE FROM ${format}_browse_node WHERE
        repository_id = #{repositoryId}
        <if test="limit gt 0"> LIMIT #{limit}</if>;
  </delete>

  <delete id="deleteBrowseNodes" databaseId="PostgreSQL">
    DELETE FROM ${format}_browse_node WHERE
        <if test="limit gt 0"> node_id IN (SELECT node_id FROM ${format}_browse_node WHERE </if>
        repository_id = #{repositoryId}
        <if test="limit gt 0"> LIMIT #{limit})</if>;
  </delete>

</mapper>
